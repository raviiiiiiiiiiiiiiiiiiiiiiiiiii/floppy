<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Floppy F4ck Maker</title>
<style>
:root{--bg:#050505;--panel:#0e0e0e;--accent:#13e37a;--muted:#9aa}
html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter,system-ui,Arial}
.wrap{max-width:980px;margin:10px auto;padding:12px}
h1{margin:0 0 8px;font-size:18px}
.subtitle{color:var(--muted);font-size:13px;margin-bottom:12px}
.panel{background:var(--panel);padding:12px;border-radius:10px;margin-top:12px}
label{display:block;font-size:13px;color:var(--muted);margin-top:8px}
input[type="text"], input[type="file"], input[type="number"], select{width:100%;box-sizing:border-box;padding:8px;border-radius:8px;border:1px solid #222;background:#070707;color:#fff;font-size:14px;margin-top:6px}
.row{display:flex;gap:8px;flex-wrap:wrap}
.col{flex:1;min-width:140px}
button{background:var(--accent);border:none;color:#031;padding:10px 12px;border-radius:8px;cursor:pointer;font-weight:700}
button.ghost{background:transparent;border:1px solid #222;color:var(--muted)}
.hint{font-size:12px;color:var(--muted);margin-top:6px}
#gameCanvas{display:block;width:100%;height:calc(100vh - 24px);background:#000;border-radius:8px;touch-action:none}
.fullHide{display:none!important}
.topOverlay{position:fixed;left:0;right:0;top:8px;display:flex;justify-content:space-between;padding:8px 14px;pointer-events:none}
.scoreBox{pointer-events:auto;background:rgba(0,0,0,0.35);padding:6px 10px;border-radius:10px;font-weight:800;font-size:20px}
.controls{pointer-events:auto;display:flex;gap:8px;align-items:center}
.iconBtn{background:rgba(0,0,0,0.35);border-radius:8px;padding:8px;color:#fff;border:1px solid rgba(255,255,255,0.06);cursor:pointer}
.center{text-align:center}
footer{margin-top:10px;color:var(--muted);font-size:12px;text-align:center}
.linkbox{display:flex;gap:8px;margin-top:8px;align-items:center}
.smallmuted{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap" id="appWrap">
  <h1>Floppy F4ck â€” Game Maker</h1>
  <div class="subtitle">Create portrait Flappy games. Upload images & sounds. Share via link (no DB).</div>

  <div id="creator" class="panel">
    <label>Game name (optional) â€” used in pretty fallback</label>
    <input id="gameName" placeholder="my-flop" />

    <div class="row">
      <div class="col">
        <label>Player image (PNG/JPG)</label>
        <input id="playerFile" type="file" accept="image/*" />
      </div>
      <div class="col">
        <label>Obstacle image (PNG/JPG)</label>
        <input id="obstFile" type="file" accept="image/*" />
      </div>
    </div>

    <label>Background image (optional)</label>
    <input id="bgFile" type="file" accept="image/*" />

    <div class="row">
      <div class="col">
        <label>In-game BGM (mp3)</label>
        <input id="bgmFile" type="file" accept="audio/*" />
      </div>
      <div class="col">
        <label>Game-over sound (mp3)</label>
        <input id="deadFile" type="file" accept="audio/*" />
      </div>
    </div>

    <label>Game-over image (PNG/JPG)</label>
    <input id="gameOverFile" type="file" accept="image/*" />
    <label>Game-over text</label>
    <input id="gameOverText" placeholder="You lost! Try again." />

    <div class="row" style="margin-top:8px">
      <div class="col"><label>Gravity</label><input id="gravity" type="number" step="0.05" value="0.5" /></div>
      <div class="col"><label>Jump Strength</label><input id="jump" type="number" step="0.5" value="8.5" /></div>
      <div class="col"><label>Pipe speed (start)</label><input id="pipeSpeed" type="number" step="0.1" value="2.2" /></div>
    </div>

    <div class="row" style="margin-top:8px">
      <div class="col"><label>Gap size (px)</label><input id="gap" type="number" value="170" /></div>
      <div class="col"><label>Spawn rate (ms)</label><input id="spawnRate" type="number" value="1400" /></div>
    </div>

    <div style="display:flex;gap:8px;margin-top:12px;flex-wrap:wrap">
      <button id="generateBtn">Generate & Play</button>
      <button id="previewBtn" class="ghost">Preview</button>
      <button id="clearBtn" class="ghost">Clear Saved</button>
    </div>

    <div id="linkArea" class="panel" style="margin-top:12px;display:none">
      <div>Shareable link (copy & paste):</div>
      <input id="shareInput" readonly style="width:100%;padding:8px;border-radius:8px;background:#070707;border:1px solid #222;color:#ddd" />
      <div class="hint smallmuted" style="margin-top:8px">Pretty path (works if your host rewrites to index.html): <code id="prettyPath"></code> â€¢ Fallback: <code id="fallbackPath"></code></div>
      <div class="linkbox">
        <button id="copyBtn">Copy</button>
        <button id="openBtn" class="ghost">Open</button>
      </div>
    </div>
  </div>

  <div id="gameShell" class="panel fullHide" style="padding:0;overflow:hidden">
    <canvas id="gameCanvas"></canvas>
    <div class="topOverlay" style="pointer-events:none">
      <div class="scoreBox" id="scoreBox" style="pointer-events:auto">0</div>
      <div class="controls" style="pointer-events:auto">
        <button id="soundToggle" class="iconBtn">ðŸ”Š</button>
        <button id="backBtn" class="iconBtn ghost">Back</button>
      </div>
    </div>
    <div id="gameOverOverlay" class="center fullHide" style="position:fixed;left:0;right:0;top:30%;pointer-events:auto">
      <div id="goImgWrap"></div>
      <div id="goTextShow" style="margin-top:12px;font-size:20px;font-weight:700"></div>
      <div style="margin-top:12px"><button id="restartBtn">Restart</button></div>
    </div>
  </div>

  <footer class="hint">Portrait fullscreen gameplay â€¢ Score on pass â€¢ Speed increases over time â€¢ Keep images/audio small if URL becomes huge</footer>
</div>

<!-- LZ-String (minimal copy) -->
<script>
/* LZ-String compressToEncodedURIComponent / decompressFromEncodedURIComponent
   Minimal included implementation for client-side URL-safe compression.
   Source logic based on LZ-String (slimmed).
*/
var LZString=(function(){function o(o){if(!t[o]){var n=new RegExp("\\b"+o+"\\b","g");t[o]=n}return t[o]}var t={};function r(o,t){for(var r=0;r<o.length;r++){var n=o.charCodeAt(r);t=(t<<5)-t+n|0}return t}function n(o){if(o==null)return"";return encodeURIComponent(o)}function e(o){if(!o)return"";return decodeURIComponent(o)}function i(o){return LZString._compress(o,6,function(o){return f.charAt(o)})}function u(o){return LZString._decompress(o,6,function(o){return f.indexOf(o)})}var f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";return{
_compress:function(o,t,r){if(o==null)return"";var n,i,u,c,s=0,l=0,a="",p=[],h={},v={},d="",m=0;for(i=0;i<o.length;i+=1){c=o.charAt(i);if(!h[c]){h[c]=1;p.push(c)}else h[c]++;}for(n=0;n<p.length;n++){v[p[n]]=n}var w=256,x=256,y=0,z="",A=2,B=3,C=2;var D="";for(i=0;i<o.length;i+=1){var c=o.charAt(i);if(!(c in v)){v[c]=w++;}var E=c; D+=E;} // fallback simple path
// Very simple fallback compression: base64-encode raw string (URIEncoded) to keep it safe
return n(btoa(unescape(encodeURIComponent(o))));},
_decompress:function(o,t,r){if(o==null)return"";try{var s=atob(decodeURIComponent(o));return decodeURIComponent(escape(s));}catch(e){try{return decodeURIComponent(o)}catch(e){return o}}}
}})();
</script>

<script>
/* -----------------------
   Main app logic
   - Uses URL encoding of full config via compressed encodedURIComponent
   - share link: /game?id=<code>
   - Option A path chosen: /game?id=...
------------------------*/
const PREFIX = "floppy"; // not used for storage but simple id
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const creator = document.getElementById('creator');
const gameShell = document.getElementById('gameShell');
const generateBtn = document.getElementById('generateBtn');
const previewBtn = document.getElementById('previewBtn');
const clearBtn = document.getElementById('clearBtn');
const linkArea = document.getElementById('linkArea');
const shareInput = document.getElementById('shareInput');
const prettyPathEl = document.getElementById('prettyPath');
const fallbackPathEl = document.getElementById('fallbackPath');
const copyBtn = document.getElementById('copyBtn');
const openBtn = document.getElementById('openBtn');
const scoreBox = document.getElementById('scoreBox');
const soundToggle = document.getElementById('soundToggle');
const backBtn = document.getElementById('backBtn');
const restartBtn = document.getElementById('restartBtn');
const goImgWrap = document.getElementById('goImgWrap');
const goTextShow = document.getElementById('goTextShow');

let audioOn = true;
soundToggle.onclick = ()=>{ audioOn = !audioOn; soundToggle.textContent = audioOn ? 'ðŸ”Š':'ðŸ”ˆ'; if(state && state.bgm){ audioOn?state.bgm.play().catch(()=>{}):state.bgm.pause(); }};

// helper: read file to dataURL
function fileToDataURL(file){ return new Promise(res=>{ if(!file){res(null);return;} const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(file); });}

// helper: sanitize name
function sanitize(s){ if(!s) return ""; return s.toLowerCase().replace(/[^a-z0-9\-]/g,'').slice(0,40); }

// build config -> compress -> build share URL
generateBtn.onclick = async ()=>{
  generateBtn.disabled = true; generateBtn.textContent = "Packing...";
  try{
    const nameRaw = sanitize(document.getElementById('gameName').value);
    const player = await fileToDataURL(document.getElementById('playerFile').files[0]);
    const obstacle = await fileToDataURL(document.getElementById('obstFile').files[0]);
    const background = await fileToDataURL(document.getElementById('bgFile').files[0]);
    const bgm = await fileToDataURL(document.getElementById('bgmFile').files[0]);
    const dead = await fileToDataURL(document.getElementById('deadFile').files[0]);
    const goImg = await fileToDataURL(document.getElementById('gameOverFile').files[0]);
    const goText = document.getElementById('gameOverText').value || "You lost!";
    const gravity = parseFloat(document.getElementById('gravity').value) || 0.5;
    const jump = parseFloat(document.getElementById('jump').value) || 8.5;
    const pipeSpeed = parseFloat(document.getElementById('pipeSpeed').value) || 2.2;
    const gap = parseInt(document.getElementById('gap').value) || 170;
    const spawnRate = parseInt(document.getElementById('spawnRate').value) || 1400;

    const cfg = { name:nameRaw, player, obstacle, background, bgm, dead, goImg, goText, gravity, jump, pipeSpeed, gap, spawnRate, v:1 };
    const json = JSON.stringify(cfg);
    // compress (using LZString wrapper to safe URI) - fallback uses base64 in our minimal LZ
    const compressed = LZString._compress(json);
    // url with path /game?id=compressed
    const searchParam = encodeURIComponent(compressed);
    const base = location.origin;
    const path = "/game";
    const full = base + path + "?id=" + searchParam;
    // pretty path (works if host rewrites): base/gameName
    const pretty = nameRaw ? (base + path + "/" + encodeURIComponent(nameRaw)) : "";
    shareInput.value = full;
    if(pretty) prettyPathEl.textContent = pretty; else prettyPathEl.textContent = "(choose game name)";
    fallbackPathEl.textContent = full;
    linkArea.style.display = 'block';
    generateBtn.textContent = "Generated!";
    // auto-open same URL (so game loads with config in URL). Use replace to avoid stacking history.
    setTimeout(()=>{ location.href = full }, 500);
  }catch(err){
    console.error(err);
    alert("Packing failed. Try smaller images/audio. Error: " + (err && err.message));
    generateBtn.disabled = false; generateBtn.textContent = "Generate & Play";
  }
};

// preview without building URL
previewBtn.onclick = async ()=>{
  const player = await fileToDataURL(document.getElementById('playerFile').files[0]);
  const obstacle = await fileToDataURL(document.getElementById('obstFile').files[0]);
  if(!player || !obstacle){ alert("Upload player and obstacle to preview"); return; }
  const cfg = {
    name: "preview",
    player, obstacle,
    background: await fileToDataURL(document.getElementById('bgFile').files[0]),
    bgm: await fileToDataURL(document.getElementById('bgmFile').files[0]),
    dead: await fileToDataURL(document.getElementById('deadFile').files[0]),
    goImg: await fileToDataURL(document.getElementById('gameOverFile').files[0]),
    goText: document.getElementById('gameOverText').value || "You lost!",
    gravity: parseFloat(document.getElementById('gravity').value)||0.5,
    jump: parseFloat(document.getElementById('jump').value)||8.5,
    pipeSpeed: parseFloat(document.getElementById('pipeSpeed').value)||2.2,
    gap: parseInt(document.getElementById('gap').value)||170,
    spawnRate: parseInt(document.getElementById('spawnRate').value)||1400,
    v:1
  };
  startGame(cfg, true);
};

clearBtn.onclick = ()=>{ if(confirm("Clear local saved links UI? This does not remove remote links.")) { linkArea.style.display='none'; shareInput.value=''; prettyPathEl.textContent=''; fallbackPathEl.textContent=''; } }
copyBtn.onclick = ()=>{ shareInput.select(); document.execCommand('copy'); copyBtn.textContent='Copied!'; setTimeout(()=>copyBtn.textContent='Copy',900); }
openBtn.onclick = ()=>{ if(shareInput.value) window.open(shareInput.value,'_blank'); }

// Routing: if path is /game and id param exists -> load config from id (decompress)
function getQueryParam(name){
  const p = new URLSearchParams(location.search);
  return p.get(name);
}
function pathSegment(){
  // for /game/<name> fallback if you choose to use pretty path later
  const p = location.pathname.split('/').filter(Boolean);
  // If URL is /game/<slug>, return slug
  if(p.length>=2 && p[0]==='game') return decodeURIComponent(p[1]);
  return null;
}
const inGameId = getQueryParam('id');
if(inGameId && location.pathname.startsWith('/game')){
  // decompress and parse
  try{
    const compressed = decodeURIComponent(inGameId);
    const json = LZString._decompress(compressed);
    const cfg = JSON.parse(json);
    // start game
    startGame(cfg, false);
  }catch(e){
    console.error("Failed to load game from URL", e);
    alert("Failed to load shared game. Maybe the link was corrupted or too large. Try again or use smaller assets.");
  }
} else {
  // if path like /game/<name> - we attempt to read id queryless (not supported unless host rewrites)
  const slug = pathSegment();
  if(slug){
    // if someone tries pretty path without id, we can't fetch remote data (there's no backend)
    alert("Pretty path requested but data must be in ?id param. Use the fallback link to share.");
  }
}

/* -----------------------------
   Game engine (portrait, 360x640 base)
   Score on pass, speed increases over time
------------------------------*/
let state = null;

function fitCanvas(){
  // base width 360 for scaling; adapt to screen width but keep tall height
  const vw = Math.min(window.innerWidth, 420);
  canvas.width = Math.max(320, vw);
  canvas.height = Math.max(560, Math.round(window.innerHeight - 12));
}
window.addEventListener('resize', fitCanvas);

function startGame(cfg, isPreview){
  // hide creator, show shell
  document.getElementById('creator').classList.add('fullHide');
  gameShell.classList.remove('fullHide');
  document.getElementById('gameOverOverlay').classList.add('fullHide');
  goImgWrap.innerHTML = "";

  fitCanvas();

  // Load images/audio (data URLs)
  const P = new Image(), O = new Image(), BG = new Image(), GO = new Image();
  if(cfg.player) P.src = cfg.player;
  if(cfg.obstacle) O.src = cfg.obstacle;
  if(cfg.background) BG.src = cfg.background;
  if(cfg.goImg) GO.src = cfg.goImg;

  let bgm = null, dead = null;
  if(cfg.bgm){ bgm = new Audio(cfg.bgm); bgm.loop = true; bgm.preload = 'auto'; }
  if(cfg.dead){ dead = new Audio(cfg.dead); dead.preload = 'auto'; }

  // initial state
  state = {
    cfg, isPreview: !!isPreview,
    player: { x: Math.round(canvas.width * 0.28), y: Math.round(canvas.height/2), w:60, h:60, vy:0 },
    pipes: [], frame:0, score:0, running:false, raf:0,
    P,O,BG,GO, bgm, dead
  };

  // scale player when image ready
  P.onload = ()=> {
    const desired = Math.round(canvas.width * 0.14);
    const ratio = (P.naturalHeight || 1) / (P.naturalWidth || 1);
    state.player.w = desired;
    state.player.h = Math.round(desired * ratio);
    state.player.y = Math.round(canvas.height/2 - state.player.h/2);
  };

  // physics
  const gravity = cfg.gravity || 0.5;
  const jump = cfg.jump || 8.5;
  let pipeSpeed = cfg.pipeSpeed || 2.2;
  const gapBase = cfg.gap || 170;
  let currentGap = gapBase;
  const spawnRate = cfg.spawnRate || 1400;
  let lastSpawn = Date.now();

  // controls
  const flap = ()=>{ if(!state.running) startRun(); state.player.vy = -Math.abs(jump); }
  canvas.addEventListener('touchstart', e=>{ e.preventDefault(); flap(); }, {passive:false});
  canvas.addEventListener('mousedown', ()=> flap());
  window.addEventListener('keydown', e=>{ if(e.code==='Space') flap(); if(e.key==='r' || e.key==='R') restartGame(); });

  function startRun(){
    if(state.running) return;
    state.running = true; state.score = 0; state.pipes=[]; state.frame=0; lastSpawn = Date.now();
    if(state.bgm && audioOn) { state.bgm.currentTime = 0; state.bgm.play().catch(()=>{}); }
    tick();
  }

  function gameOver(){
    if(!state.running) return;
    state.running = false;
    if(state.bgm){ try{ state.bgm.pause(); state.bgm.currentTime = 0; }catch(e){} }
    if(state.dead && audioOn){ try{ state.dead.currentTime = 0; state.dead.play().catch(()=>{}); }catch(e){} }
    // show overlay
    goImgWrap.innerHTML = "";
    if(state.GO && state.GO.src){
      const img = document.createElement('img');
      img.src = state.GO.src;
      img.style.maxWidth = "68%";
      img.style.maxHeight = "30vh";
      img.style.borderRadius = "8px";
      goImgWrap.appendChild(img);
    }
    goTextShow.textContent = state.cfg.goText || "You lost!";
    document.getElementById('gameOverOverlay').classList.remove('fullHide');
    restartBtn.style.display = 'inline-block';
    scoreBox.textContent = state.score;
  }

  function spawnPair(){
    const minTop = 40;
    const maxTop = Math.max(80, canvas.height - currentGap - 120);
    const topH = minTop + Math.floor(Math.random()*(Math.max(0, maxTop - minTop)));
    const bottomY = topH + currentGap;
    const w = Math.max(40, Math.round(canvas.width * 0.20)); // slim pipes
    const pairId = Date.now() + Math.random();
    state.pipes.push({ x: canvas.width + 20, y: 0, w, h: topH, top:true, pairId });
    state.pipes.push({ x: canvas.width + 20, y: bottomY, w, h: canvas.height - bottomY, top:false, pairId });
  }

  function tick(){
    update();
    render();
    if(state.running) state.raf = requestAnimationFrame(tick);
  }

  function update(){
    state.frame++;
    state.player.vy += gravity;
    state.player.y += state.player.vy;

    // spawn by time
    if(Date.now() - lastSpawn >= spawnRate){
      lastSpawn = Date.now();
      spawnPair();
    }

    // move pipes & scoring (score on pass of top pipe)
    for(let i = state.pipes.length-1; i>=0; i--){
      const p = state.pipes[i];
      p.x -= pipeSpeed;
      if(!p._scored && p.top && (p.x + p.w) < state.player.x){
        state.score++;
        scoreBox.textContent = state.score;
        p._scored = true;
      }
      if(p.x + p.w < -100) state.pipes.splice(i,1);
    }

    // collisions with walls
    if(state.player.y + state.player.h > canvas.height || state.player.y < 0) return gameOver();
    for(const p of state.pipes){
      if(rectOverlap(state.player.x, state.player.y, state.player.w, state.player.h, p.x, p.y, p.w, p.h)){
        return gameOver();
      }
    }

    // difficulty progression
    if(state.frame % 600 === 0){
      pipeSpeed += 0.25;
      currentGap = Math.max(90, currentGap - 6);
    }
  }

  function rectOverlap(x1,y1,w1,h1,x2,y2,w2,h2){
    return !(x2 > x1 + w1 || x2 + w2 < x1 || y2 > y1 + h1 || y2 + h1 < y1);
  }

  function render(){
    // background
    if(state.BG && state.BG.src && state.BG.complete){
      ctx.drawImage(state.BG, 0, 0, state.BG.naturalWidth, state.BG.naturalHeight, 0, 0, canvas.width, canvas.height);
    } else {
      ctx.fillStyle = "#081018"; ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // pipes
    for(const p of state.pipes){
      if(state.O && state.O.src && state.O.complete){
        ctx.save();
        if(p.top){
          ctx.translate(p.x + p.w/2, p.y + p.h/2);
          ctx.scale(1,-1);
          ctx.drawImage(state.O, -p.w/2, -p.h/2, p.w, p.h);
          ctx.restore();
        } else {
          ctx.drawImage(state.O, p.x, p.y, p.w, p.h);
        }
      } else {
        ctx.fillStyle = "#aa4422"; ctx.fillRect(p.x, p.y, p.w, p.h);
      }
    }

    // player
    if(state.P && state.P.src && state.P.complete){
      ctx.drawImage(state.P, state.player.x, state.player.y, state.player.w, state.player.h);
    } else {
      ctx.fillStyle = "#ffd92e"; ctx.fillRect(state.player.x, state.player.y, state.player.w, state.player.h);
    }
  }

  // wire UI
  restartBtn.onclick = ()=>{ if(state && state.cfg) startGame(state.cfg, state.isPreview); }
  backBtn.onclick = ()=>{ location.href = location.pathname; }
  scoreBox.textContent = state.score;
  restartBtn.style.display = 'none';
  document.getElementById('gameOverOverlay').classList.add('fullHide');

  // auto-start on first tap if not preview
  // For preview, start immediately for convenience
  if(isPreview) startRun();
}

// small error catch
window.addEventListener('error', e=>console.error('Runtime error', e));
</script>
</body>
</html>
