<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Floppy F4ck Maker</title>
<style>
  :root{--bg:#050505;--panel:#0d0d0d;--accent:#13e37a;--muted:#9aa;}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter,system-ui,Arial}
  .wrap{max-width:980px;margin:10px auto;padding:12px}
  h1{margin:0 0 8px;font-size:18px}
  .subtitle{color:var(--muted);font-size:13px;margin-bottom:12px}
  .panel{background:var(--panel);padding:12px;border-radius:10px;margin-top:12px}
  label{display:block;font-size:13px;color:var(--muted);margin-top:8px}
  input[type="text"], input[type="file"], input[type="number"], select{
    width:100%;box-sizing:border-box;padding:8px;border-radius:8px;border:1px solid #222;background:#070707;color:#fff;font-size:14px;margin-top:6px;
  }
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .col{flex:1;min-width:140px}
  button{background:var(--accent);border:none;color:#031;padding:10px 12px;border-radius:8px;cursor:pointer;font-weight:700}
  button.ghost{background:transparent;border:1px solid #222;color:var(--muted)}
  .hint{font-size:12px;color:var(--muted);margin-top:6px}
  #gameCanvas{display:block;width:100%;height:calc(100vh - 24px);background:#000;border-radius:8px;touch-action:none}
  .fullHide{display:none!important}
  .topOverlay{position:fixed;left:0;right:0;top:8px;display:flex;justify-content:space-between;padding:8px 14px;pointer-events:none}
  .scoreBox{pointer-events:auto;background:rgba(0,0,0,0.35);padding:6px 10px;border-radius:10px;font-weight:800;font-size:20px}
  .controls{pointer-events:auto;display:flex;gap:8px;align-items:center}
  .iconBtn{background:rgba(0,0,0,0.35);border-radius:8px;padding:8px;color:#fff;border:1px solid rgba(255,255,255,0.06);cursor:pointer}
  .center{text-align:center}
  footer{margin-top:10px;color:var(--muted);font-size:12px;text-align:center}
  @media(min-width:880px){ .wrap{max-width:980px} }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Floppy F4ck â€” Game Maker</h1>
    <div class="subtitle">Create portrait Flappy games. Upload your own images & sounds. No backend. Share via link.</div>

    <div id="creator" class="panel">
      <label>Game name (optional) â€” used in share link (lowercase, hyphens allowed)</label>
      <input id="gameName" placeholder="my-flop" />

      <div class="row">
        <div class="col">
          <label>Player image (PNG/JPG)</label>
          <input id="playerFile" type="file" accept="image/*" />
        </div>
        <div class="col">
          <label>Obstacle image (PNG/JPG)</label>
          <input id="obstFile" type="file" accept="image/*" />
        </div>
      </div>

      <label>Background image (optional)</label>
      <input id="bgFile" type="file" accept="image/*" />

      <div class="row">
        <div class="col">
          <label>In-game BGM (mp3)</label>
          <input id="bgmFile" type="file" accept="audio/*" />
        </div>
        <div class="col">
          <label>Game-over sound (mp3)</label>
          <input id="deadFile" type="file" accept="audio/*" />
        </div>
      </div>

      <label>Game-over image (PNG/JPG)</label>
      <input id="gameOverImage" type="file" accept="image/*" />
      <label>Game-over text</label>
      <input id="gameOverText" placeholder="You lost! Try again." />

      <div class="row" style="margin-top:10px">
        <div class="col">
          <label>Gravity</label>
          <input id="gravity" type="number" step="0.05" value="0.55" />
        </div>
        <div class="col">
          <label>Jump Strength</label>
          <input id="jumpStrength" type="number" step="0.5" value="9" />
        </div>
        <div class="col">
          <label>Pipe speed (start)</label>
          <input id="pipeSpeed" type="number" step="0.1" value="2.4" />
        </div>
      </div>

      <div class="row" style="margin-top:8px">
        <div class="col">
          <label>Gap size (px)</label>
          <input id="pipeGap" type="number" value="150" />
        </div>
        <div class="col">
          <label>Spawn rate (ms)</label>
          <input id="spawnRate" type="number" value="1500" />
        </div>
      </div>

      <div style="display:flex;gap:8px;margin-top:12px;flex-wrap:wrap">
        <button id="generateBtn">Generate Game</button>
        <button id="previewBtn" class="ghost">Preview</button>
        <button id="clearBtn" class="ghost">Clear Saved</button>
      </div>

      <div id="linkArea" class="panel" style="margin-top:12px;display:none">
        <div style="margin-bottom:8px">Shareable links (copy & paste):</div>
        <input id="shareInput" readonly style="width:100%;padding:8px;border-radius:8px;background:#070707;border:1px solid #222;color:#ddd" />
        <div class="hint" style="margin-top:8px">Pretty path (works if you deploy SPA on Vercel/Netlify): <code id="prettyPath"></code>. Fallback query param: <code id="fallbackPath"></code></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="copyBtn">Copy</button>
          <button id="openBtn" class="ghost">Open</button>
        </div>
      </div>
    </div>

    <!-- Game shell -->
    <div id="gameShell" class="panel fullHide" style="padding:0;overflow:hidden">
      <canvas id="gameCanvas"></canvas>

      <div class="topOverlay" style="pointer-events:none">
        <div class="scoreBox" id="scoreBox" style="pointer-events:auto">0</div>
        <div class="controls" style="pointer-events:auto">
          <button id="soundToggle" class="iconBtn">ðŸ”Š</button>
          <button id="backBtn" class="iconBtn ghost">Back</button>
        </div>
      </div>

      <div id="gameOverOverlay" class="center fullHide" style="position:fixed;left:0;right:0;top:30%;pointer-events:auto">
        <div id="goImgWrap"></div>
        <div id="goTextShow" style="margin-top:12px;font-size:20px;font-weight:700"></div>
        <div style="margin-top:12px"><button id="restartBtn">Restart</button></div>
      </div>
    </div>

    <footer class="hint">Portrait fullscreen gameplay â€¢ Score on pass â€¢ Speed increases over time â€¢ Keep assets small (localStorage ~5MB)</footer>
  </div>

<script>
/* --------------------------
   Helpers
   -------------------------- */
const $ = id => document.getElementById(id);
const PREFIX = "floppy_game_";
const toBase64 = f => new Promise(res => {
  if(!f){ res(null); return; }
  const r = new FileReader(); r.onload = ()=> res(r.result); r.onerror = ()=> res(null); r.readAsDataURL(f);
});
const randId = (n=7)=>{const s="abcdefghijklmnopqrstuvwxyz0123456789";let r="";for(let i=0;i<n;i++) r+=s[Math.floor(Math.random()*s.length)];return r;}
const sanitizeName = s => s ? s.toLowerCase().replace(/[^a-z0-9\-]/g,'').slice(0,40) : "";

/* --------------------------
   DOM refs
   -------------------------- */
const generateBtn = $('generateBtn'), previewBtn = $('previewBtn'), clearBtn = $('clearBtn');
const copyBtn = $('copyBtn'), openBtn = $('openBtn');
const linkArea = $('linkArea'), shareInput = $('shareInput'), prettyPath = $('prettyPath'), fallbackPath = $('fallbackPath');
const gameShell = $('gameShell'), creator = $('creator'), goImgWrap = $('goImgWrap'), goTextShow = $('goTextShow');
const canvas = $('gameCanvas'), ctx = canvas.getContext('2d');
const scoreBox = $('scoreBox'), soundToggle = $('soundToggle'), backBtn = $('backBtn'), restartBtn = $('restartBtn');
let audioOn = true;
soundToggle.onclick = ()=>{ audioOn = !audioOn; soundToggle.textContent = audioOn ? 'ðŸ”Š' : 'ðŸ”ˆ'; if(state && state.bgm) { audioOn ? state.bgm.play().catch(()=>{}) : state.bgm.pause(); } }

/* --------------------------
   Storage helpers
   -------------------------- */
function saveConfig(id, obj){
  try{ localStorage.setItem(PREFIX + id, JSON.stringify(obj)); return true; } catch(e){ console.error("save failed", e); return false; }
}
function loadConfig(id){ try{ const v = localStorage.getItem(PREFIX + id); return v ? JSON.parse(v) : null; } catch(e){ return null; } }
function clearConfigs(){ Object.keys(localStorage).forEach(k => { if(k.startsWith(PREFIX)) localStorage.removeItem(k); }); }

/* --------------------------
   Creator actions
   -------------------------- */
generateBtn.onclick = async () => {
  generateBtn.disabled = true; generateBtn.textContent = "Saving...";
  const nameRaw = sanitizeName($('gameName').value);
  const idBase = nameRaw || randId(7);
  let id = idBase;
  if(loadConfig(id)){ let i=1; while(loadConfig(id + i)) i++; id = id + i; } // avoid collision

  const player = await toBase64($('playerFile').files[0]);
  const obst = await toBase64($('obstFile').files[0]);
  const bg = await toBase64($('bgFile').files[0]);
  const bgm = await toBase64($('bgmFile').files[0]);
  const dead = await toBase64($('deadFile').files[0]);
  const goImg = await toBase64($('gameOverImage').files[0]);
  const goText = $('gameOverText').value || 'You lost!';

  const cfg = {
    id, created: Date.now(),
    player, obstacle:obst, background:bg,
    bgm, dead, gameOverImage:goImg, gameOverText:goText,
    gravity: parseFloat($('gravity').value) || 0.55,
    jump: parseFloat($('jumpStrength').value) || 9,
    pipeSpeed: parseFloat($('pipeSpeed').value) || 2.4,
    gap: parseInt($('pipeGap').value) || 150,
    spawnRate: parseInt($('spawnRate').value) || 1500
  };

  const ok = saveConfig(id, cfg);
  generateBtn.disabled = false; generateBtn.textContent = "Generate Game";
  if(!ok){ alert("Save failed â€” localStorage quota. Compress images/sounds or pick smaller files."); return; }

  // build share links
  const origin = location.origin;
  const pathPretty = origin + "/" + encodeURIComponent(id); // pretty path (requires SPA fallback on server)
  const fallback = origin + location.pathname + "?id=" + encodeURIComponent(id); // guaranteed
  shareInput.value = fallback;
  prettyPath.textContent = pathPretty;
  fallbackPath.textContent = fallback;
  linkArea.style.display = 'block';
  copyBtn.focus();

  // auto-redirect to playable link
  setTimeout(()=> { location.href = fallback }, 600);
};

previewBtn.onclick = async () => {
  // quick preview (temp config)
  const player = await toBase64($('playerFile').files[0]);
  const obst = await toBase64($('obstFile').files[0]);
  if(!player || !obst){ alert("Upload player + obstacle to preview"); return; }
  const cfg = {
    id: "preview_"+Date.now(),
    player, obstacle:obst, background: await toBase64($('bgFile').files[0]),
    bgm: await toBase64($('bgmFile').files[0]), dead: await toBase64($('deadFile').files[0]),
    gameOverImage: await toBase64($('gameOverImage').files[0]), gameOverText: $('gameOverText').value || "You lost!",
    gravity: parseFloat($('gravity').value)||0.55, jump: parseFloat($('jumpStrength').value)||9,
    pipeSpeed: parseFloat($('pipeSpeed').value)||2.4, gap: parseInt($('pipeGap').value)||150, spawnRate: parseInt($('spawnRate').value)||1500
  };
  startGame(cfg, true);
};

clearBtn.onclick = ()=> { if(confirm("Clear all saved games from this browser?")){ clearConfigs(); alert("Cleared."); linkArea.style.display='none'; } }
copyBtn.onclick = ()=>{ shareInput.select(); document.execCommand('copy'); copyBtn.textContent='Copied!'; setTimeout(()=>copyBtn.textContent='Copy',900); }
openBtn.onclick = ()=>{ if(shareInput.value) window.open(shareInput.value,'_blank') }

/* --------------------------
   Routing: load config if ?id= or path
   -------------------------- */
function pathGameId(){
  // If URL is https://domain.com/some-id (single-segment path), return that sanitized segment
  const p = location.pathname.replace(/^\/+|\/+$/g,''); // strip slashes
  if(p && p !== (location.origin.replace(/^https?:\/\//,''))) return decodeURIComponent(p);
  return null;
}
const urlParams = new URLSearchParams(location.search);
const qId = urlParams.get('id');
const pathId = pathGameId();
const playId = qId || pathId;
if(playId){
  const cfg = loadConfig(playId);
  if(!cfg){
    // show creator but inform
    alert("Game not found locally. Make sure the creator saved & shared correctly. If you created this on another device, it's only stored in that device's browser localStorage.");
  } else {
    startGame(cfg, false);
  }
}

/* --------------------------
   Game engine (portrait vertical pipes)
   Score: increment when passing pair (B)
   Speed: increases over time (A)
   -------------------------- */
let state = null;
function startGame(cfg, isPreview){
  // hide creator, show shell
  creator.classList.add('fullHide');
  gameShell.classList.remove('fullHide');
  goImgWrap.innerHTML = "";
  $('gameCanvas').style.display = "block";

  // setup canvas to fill viewport height (portrait)
  function fitCanvas(){
    const w = Math.min(window.innerWidth - 12, 480);
    const h = Math.max(520, window.innerHeight - 12);
    canvas.width = Math.max(320, w);
    canvas.height = h;
  }
  fitCanvas(); window.addEventListener('resize', fitCanvas);

  // load assets
  const P = new Image(), O = new Image(), BG = new Image(), GO = new Image();
  if(cfg.player) P.src = cfg.player;
  if(cfg.obstacle) O.src = cfg.obstacle;
  if(cfg.background) BG.src = cfg.background;
  if(cfg.gameOverImage) GO.src = cfg.gameOverImage;

  let bgm = null, dead = null;
  if(cfg.bgm){ bgm = new Audio(cfg.bgm); bgm.loop = true; bgm.preload='auto'; }
  if(cfg.dead){ dead = new Audio(cfg.dead); dead.preload='auto'; }

  // state init
  state = {
    cfg, isPreview: !!isPreview,
    player: { x: Math.round(canvas.width * 0.28), y: Math.round(canvas.height/2), w:60, h:60, vy:0 },
    pipes: [], score:0, running:false, frame:0, raf:0,
    bgm, dead, P, O, BG, GO
  };

  // scale player when image ready
  P.onload = ()=> {
    const desired = Math.round(canvas.width * 0.14);
    const ratio = P.naturalHeight / (P.naturalWidth || 1);
    state.player.w = desired;
    state.player.h = Math.round(desired * ratio);
    state.player.y = Math.round(canvas.height/2 - state.player.h/2);
  };

  // physics/difficulty
  const gravity = cfg.gravity || 0.55;
  const jump = cfg.jump || 9;
  let pipeSpeed = cfg.pipeSpeed || 2.4;
  const gapBase = cfg.gap || 150;
  let currentGap = gapBase;
  const spawnRate = cfg.spawnRate || 1500; // ms
  let lastSpawn = Date.now();

  // controls: tap/click to flap
  const flap = ()=>{ if(!state.running) startRun(); state.player.vy = -Math.abs(jump); }
  canvas.addEventListener('touchstart', e=>{ e.preventDefault(); flap(); }, {passive:false});
  canvas.addEventListener('mousedown', ()=> flap());

  function startRun(){
    if(state.running) return;
    state.running = true; state.score = 0; state.pipes=[]; state.frame = 0; lastSpawn = Date.now();
    // play bgm
    if(state.bgm && audioOn){ state.bgm.currentTime = 0; state.bgm.play().catch(()=>{}); }
    tick();
  }

  function gameOver(){
    if(!state.running) return;
    state.running = false;
    if(state.bgm){ try{ state.bgm.pause(); state.bgm.currentTime = 0; }catch(e){} }
    if(state.dead && audioOn){ state.dead.currentTime = 0; state.dead.play().catch(()=>{}); }
    // show game over UI
    goImgWrap.innerHTML = "";
    if(state.GO && state.GO.src){
      const img = document.createElement('img');
      img.src = state.GO.src;
      img.style.maxWidth = "68%";
      img.style.maxHeight = "30vh";
      img.style.borderRadius = "8px";
      goImgWrap.appendChild(img);
    }
    goTextShow.textContent = state.cfg.gameOverText || "You lost!";
    $('gameOverOverlay').classList.remove('fullHide');
    restartBtn.style.display = 'inline-block';
    scoreBox.textContent = state.score;
  }

  function spawnPair(){
    // top height random, bottom begins after gap
    const minTop = 40;
    const maxTop = Math.max(80, canvas.height - currentGap - 120);
    const topH = minTop + Math.floor(Math.random()*(Math.max(0, maxTop - minTop)));
    const bottomY = topH + currentGap;
    // narrow obstacle width for playability
    const w = Math.max(48, Math.round(canvas.width * 0.22));
    state.pipes.push({ x: canvas.width + 20, y: 0, w, h: topH, top:true, pairId: Date.now()+Math.random() });
    state.pipes.push({ x: canvas.width + 20, y: bottomY, w, h: canvas.height - bottomY, top:false, pairId: Date.now()+Math.random() });
  }

  function tick(){
    update();
    render();
    if(state.running) state.raf = requestAnimationFrame(tick);
  }

  function update(){
    state.frame++;
    // physics
    state.player.vy += gravity;
    state.player.y += state.player.vy;

    // spawn based on time
    if(Date.now() - lastSpawn >= spawnRate){
      lastSpawn = Date.now();
      spawnPair();
    }

    // move pipes and scoring
    for(let i = state.pipes.length-1; i>=0; i--){
      const p = state.pipes[i];
      p.x -= pipeSpeed;
      if(!p._scored && p.top && (p.x + p.w) < state.player.x){
        // when top pipe passed player's x, increment score ONCE
        state.score++;
        scoreBox.textContent = state.score;
        p._scored = true;
      }
      if(p.x + p.w < -100) state.pipes.splice(i,1);
    }

    // collisions
    if(state.player.y + state.player.h > canvas.height || state.player.y < 0) return gameOver();
    for(const p of state.pipes){
      if(rectOverlap(state.player.x, state.player.y, state.player.w, state.player.h, p.x, p.y, p.w, p.h)){
        return gameOver();
      }
    }

    // speed/difficulty progression (every ~10s)
    if(state.frame % 600 === 0){
      pipeSpeed += 0.25;
      currentGap = Math.max(90, currentGap - 6);
    }
  }

  function rectOverlap(x1,y1,w1,h1,x2,y2,w2,h2){
    return !(x2 > x1 + w1 || x2 + w2 < x1 || y2 > y1 + h1 || y2 + h2 < y1);
  }

  function render(){
    // background
    if(state.BG && state.BG.src && state.BG.complete){
      ctx.drawImage(state.BG, 0, 0, state.BG.naturalWidth, state.BG.naturalHeight, 0, 0, canvas.width, canvas.height);
    } else {
      ctx.fillStyle = "#081018"; ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // pipes
    for(const p of state.pipes){
      if(state.O && state.O.src && state.O.complete){
        ctx.save();
        if(p.top){
          ctx.translate(p.x + p.w/2, p.y + p.h/2);
          ctx.scale(1,-1);
          ctx.drawImage(state.O, -p.w/2, -p.h/2, p.w, p.h);
          ctx.restore();
        } else {
          ctx.drawImage(state.O, p.x, p.y, p.w, p.h);
        }
      } else {
        ctx.fillStyle = "#aa4422"; ctx.fillRect(p.x, p.y, p.w, p.h);
      }
    }

    // player
    if(state.P && state.P.src && state.P.complete){
      ctx.drawImage(state.P, state.player.x, state.player.y, state.player.w, state.player.h);
    } else {
      ctx.fillStyle = "#ffd92e"; ctx.fillRect(state.player.x, state.player.y, state.player.w, state.player.h);
    }
  }

  // set state image refs for render functions
  state.P = P; state.O = O; state.BG = BG; state.GO = GO;
  scoreBox.textContent = state.score;
  restartBtn.style.display = 'none';
  $('gameOverOverlay').classList.add('fullHide');

  // start automatically on first interaction (tap)
  // If preview: start immediately
  if(isPreview) startRun();
  // otherwise wait for first flap (tap starts it)
}

/* --------------------------
   restart/back handlers
   -------------------------- */
restartBtn.onclick = ()=> { if(state && state.cfg) startGame(state.cfg, state.isPreview); }
backBtn.onclick = ()=> { location.href = location.pathname; }

/* --------------------------
   small helpers
   -------------------------- */
function rectOverlap(x1,y1,w1,h1,x2,y2,w2,h2){
  return !(x2 > x1 + w1 || x2 + w2 < x1 || y2 > y1 + h1 || y2 + h2 < y1);
}

/* --------------------------
   Debug safety
   -------------------------- */
window.addEventListener('error', e=> console.error('Runtime error', e));
</script>
</body>
</html>
